import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Job {

    public static void main(String[] args) {
        String logFilePath = "C:\\1 Sarah Labtop\\1 Sarah\\2 Bacholar degree\\1 2023 2034\\2 Sem2\\2 Classes\\WIX1002 FUNDAMENTALS OF PROGRAMMING\\fop assignment\\assignment\\Code4Error\\extracted_log.txt"; // Adjust this path as needed

        // Variables for job partition counting
        List<String> partitions = new ArrayList<>();
        List<Integer> partitionCounts = new ArrayList<>();

        // Variables for job timing and error counting
        LocalDateTime startTime = null;
        LocalDateTime endTime = null;
        int createdCount = 0;
        int endedCount = 0;
        int errorJobs = 0;
        int completedWithZero = 0;
        int completedWithPositive = 0;
        int killedJobs = 0; // Counter for killed jobs
        Map<String, Integer> userErrorCount = new HashMap<>();
        long totalExecutionTimeSeconds = 0; // Total execution time in seconds
        int jobCount = 0; // Total number of jobs

        // Patterns for matching relevant log entries
        Pattern allocatePattern = Pattern.compile("sched: Allocate");
        Pattern submitPattern = Pattern.compile("_slurm_rpc_submit_batch_job");
        Pattern completePattern = Pattern.compile("_job_complete");
        Pattern errorPattern = Pattern.compile("error:.*user='(\\S+)'");
        Pattern exitStatusPattern = Pattern.compile("_job_complete: JobId=(\\d+) WEXITSTATUS (\\d+)");
        Pattern killPattern = Pattern.compile("_slurm_rpc_kill_job"); // Pattern to match killed jobs

        try (BufferedReader reader = new BufferedReader(new FileReader(logFilePath))) {
            String line;
            while ((line = reader.readLine()) != null) {
                // Job partition counting
                Matcher allocateMatcher = allocatePattern.matcher(line);
                if (allocateMatcher.find()) {
                    String partition = line.substring(line.lastIndexOf("Partition=") + 10).trim();
                    int index = partitions.indexOf(partition);
                    if (index == -1) {
                        partitions.add(partition);
                        partitionCounts.add(1);
                    } else {
                        partitionCounts.set(index, partitionCounts.get(index) + 1);
                    }
                }

                // Job timing and error counting
                LocalDateTime timestamp = LocalDateTime.parse(line.substring(1, 24), DateTimeFormatter.ISO_DATE_TIME);
                if (startTime == null || timestamp.isBefore(startTime)) {
                    startTime = timestamp;
                }
                if (endTime == null || timestamp.isAfter(endTime)) {
                    endTime = timestamp;
                }
                if (submitPattern.matcher(line).find()) {
                    createdCount++;
                } else if (completePattern.matcher(line).find()) {
                    endedCount++;
                    Matcher exitStatusMatcher = exitStatusPattern.matcher(line);
                    if (exitStatusMatcher.find()) {
                        int exitStatus = Integer.parseInt(exitStatusMatcher.group(2));
                        if (exitStatus == 0) {
                            completedWithZero++;
                        } else {
                            completedWithPositive++;
                        }
                    }

                    // Calculate job execution time
                    Duration executionTime = calculateExecutionTime(startTime, timestamp);
                    totalExecutionTimeSeconds += executionTime.getSeconds();
                    jobCount++;
                }

                // Counting job errors
                Matcher errorMatcher = errorPattern.matcher(line);
                if (errorMatcher.find()) {
                    errorJobs++;
                    String user = errorMatcher.group(1);
                    userErrorCount.put(user, userErrorCount.getOrDefault(user, 0) + 1);
                }

                // Counting killed jobs
                if (killPattern.matcher(line).find()) {
                    killedJobs++;
                }
            }
        } catch (IOException e) {
            System.err.println("Error reading the log file: " + e.getMessage());
        }

        // Print job partition counts
        System.out.println("Job Partition Counts:");
        System.out.println("+----------------------+----------+");
        System.out.println("| Partition            | Count    |");
        System.out.println("+----------------------+----------+");
        for (int i = 0; i < partitions.size(); i++) {
            System.out.printf("| %-20s | %-8d |\n", partitions.get(i), partitionCounts.get(i));
        }
        System.out.println("+----------------------+----------+");
        System.out.println();

        // Print job timing information
        System.out.println("Job Timing Information:");
        System.out.println("+-----------------------------+-----------------------------+");
        System.out.printf("| %-27s | %-27s |\n", "Start Time", startTime);
        System.out.printf("| %-27s | %-27s |\n", "End Time", endTime);
        System.out.printf("| %-27s | %-27d |\n", "Number of Jobs Created", createdCount);
        System.out.printf("| %-27s | %-27d |\n", "Number of Jobs Ended", endedCount);
        System.out.println("+-----------------------------+-----------------------------+");
        System.out.println();

        // Print job error information
        System.out.println("Job Error Information:");
        System.out.println("+----------------------+-------------+");
        System.out.println("| User                 | Error Count |");
        System.out.println("+----------------------+-------------+");
        userErrorCount.forEach((user, count) -> 
            System.out.printf("| %-20s | %-8d |\n", user, count)
        );
        System.out.println("+----------------------+----------+");
        System.out.println();

        // Print job completion with exit status information
        System.out.println("Job Completion Information:");
        System.out.println("+------------------------------------------------+----------+");
        System.out.printf("| %-48s | %-8d |\n", "Number of Jobs Completed with WEXITSTATUS 0", completedWithZero);
        System.out.printf("| %-48s | %-8d |\n", "Number of Jobs Completed with Positive WEXITSTATUS", completedWithPositive);
        System.out.println("+------------------------------------------------+----------+");
        System.out.println();
        
        // Print job error information
        System.out.println("Job Error Information:");
                System.out.println("+------------------------------------------------+----------+");
        System.out.printf("| %-48s | %-8d |\n", "Number of Jobs Killed", killedJobs);
        System.out.println("+------------------------------------------------+----------+");
        System.out.println();

        // Calculate and print average execution time
        System.out.println("Job Execution Time:");
        if (jobCount > 0) {
            long averageExecutionTimeSeconds = totalExecutionTimeSeconds / jobCount;
            System.out.println("+-----------------------------+-----------------------------+");
            System.out.printf("| %-27s | %-27s |\n", "Average Execution Time of Jobs", formatDuration(Duration.ofSeconds(averageExecutionTimeSeconds)));
            System.out.println("+-----------------------------+-----------------------------+");
        } else {
            System.out.println("No jobs found to calculate average execution time.");
        }
    }

    // Method to calculate execution time between two timestamps
    private static Duration calculateExecutionTime(LocalDateTime start, LocalDateTime end) {
        return Duration.between(start, end);
    }

    // Method to format duration in HH:mm:ss format
    private static String formatDuration(Duration duration) {
        long hours = duration.toHours();
        long minutes = duration.toMinutesPart();
        long seconds = duration.toSecondsPart();
        return String.format("%02d:%02d:%02d", hours, minutes, seconds);
    }
}
